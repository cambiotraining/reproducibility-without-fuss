[["index.html", "Reproducibility without fuss Chapter 1 Introduction 1.1 Objectives 1.2 Purpose and aim 1.3 Causes of irreproducibility 1.4 Solutions to irreproducibility 1.5 Exercise: forensic science 1.6 Key points 1.7 Authors and materials", " Reproducibility without fuss Martin van Rongen 2023-07-24 Chapter 1 Introduction 1.1 Objectives Understand the importance of reproducibility in the scientific method Explore practical ways to aid reproducibility 1.2 Purpose and aim Reproducibility of experiments is an important part of the scientific method. It goes all the way back to the 17th century, when the Irish chemist Robert Boyle was studying the concept of vacuum - a rather controversial topic at the time. Boyle argued that facts will emerge when an experiment is repeated over and over again - with consistent outcomes, presumably. Here we are looking at various causes of irreproducibility and, importantly, we look at how we can avoid this happening in the first place. 1.3 Causes of irreproducibility 1.3.1 Not a true result Publication bias This happens because the research community tends to favour publishing statistically significant results. It’s generally more difficult to publish non-significant results, even if the experimental design, data collection and subsequent analysis are sound. HARKing This is Hypothesising After the Results are Known. What happens is that researchers gather data, do an analysis and then formulate a hypothesis based on these data. p-Hacking / selective reporting This occurs when researchers perform multiple statistical analyses on their data and then report the ones that produce statistically significant results. Low statistical power Here a statistically significant result may be found, but the power of the analysis may be low. If there is low statistical power, then the likelihood of a statistical test detecting a true effect when there is one, is low. Faulty data analysis This happens. A lot. We’re only human - there are many reasons why this can occur, for example poor practice (sorting the wrong column in Excel), lack of knowledge, errors in code etc. Poor experimental design The outcome of an experiment can only be robust if there is a decent experimental design. Problems with experimental design can include low subject numbers (leading to poor statistical power), lack of controls, inaccurate measurements, measuring the wrong thing etc. Fraud This is what people often think of when it comes to irreproducible research. Hopefully it is less common than it may seem to be. In a way there is probably a bias towards reporting cases of fraud, as opposed to genuine mistakes by researchers. A lot of the causes we covered above can actually contribute to a researcher committing fraud. Academic pressures are real and the need to publish, preferably in high-impact journals, can definitely contribute to this. Bad luck A tough one. You can have the best experimental design in the world, multiple replicates, high sample sizes, good statistical power but… you’re just plain unlucky and you picked up a result that others cannot reproduce. 1.3.2 Insufficient information Data unavailable I hate it when this happens. It reduces a scientific article to “you just have to take my word for it”. It is not just the researchers who are to blame here - editors and journals should insist on data being available. Methods unavailable / not clear Unavailable methods are unnecessary, they can be picked up at the review stage. Unclear methods are a bit trickier because what may be blatantly obvious to the original researcher, might be vague to others. Let your colleagues proof-read, preferably that person you have coffee with on Mondays but knows nothing about your research… Code unavailable Again, unnecessary. Editors, reviewers and journals should insist on this. It could be that there is no code, because the analysis was done in Excel for example. Although that is far from ideal, then at least the spreadsheet should be available for others to check. 1.3.3 Issues with replication Poor reproduction methods This is often linked to unclear methods. You can’t reproduce something if it isn’t clear how the experiment was done in the first place! Other issues arise when a unique piece of hardware was used to generate the data (not everyone has a hadron collider under their lawn), but there independent researchers could use the same machinery. Or perhaps the work is extremely fiddly and requires a lot of skill and knowledge, that other researcher may not have. Variability in standard reagents One of many variables in an experimental setup that can cause havoc. 1.4 Solutions to irreproducibility 1.4.1 The right stuff Ethical integrity Don’t go into science if you don’t care about this. Or into anything, really. Have the right knowledge Make sure you have sufficient understanding of statistics and experimental design to perform and analyse your experiment properly. If you don’t, then educate yourself or collaborate with somebody who can assist in the areas where your knowledge is lacking. Better oversight This can and should happen at every level. Group leaders, editors, reviewers, colleagues, research assistants etc all play a role in getting from an idea to a published result. At each stage there is opportunity to reflect and ask if what is being done happens correctly. Better data management Be organised. Be transparent. Use non-proprietary data formats. Make data freely available. 1.4.2 Making reproducing easy Organisation Being organised not only makes reproducing research easier, it also avoids problems in the first place. We’ll see an example in the exercise of this chapter where things are… not organised. Organising your research and analysis occurs at all kinds of levels, such as the data that you generate or pull in externally; the scripts you create to analyse the data (the code within them needs to be organised); the processed files and images you generate etc. Documentation Write things down! Be clear and concise! It really does help. I can be rather forgetful, which is actually really helpful in this case. Because I don’t trust myself to remember things, I make sure I write them down (in an organised way). The way I see it, if I can reproduce my own research and thoughts, then others should be able to as well. Documentation is a pretty broad topic, which we’ll cover in more detail. But it includes documenting your data (meta data on location, subjects, units etc), documenting your methods, analysis, code, images and more. Automation Not only is it efficient to automate processes, it also makes data gathering and analysis less error-prone. Imagine having to generate graphs for 10 different groups, using Excel and selecting the data by hand… how likely will it be you’ll accidentally select the wrong cells? Much better to make sure your data is in the right format and you use a programming language such as R or Python to sort things out for you. Yes, the initial learning curve might be a bit steeper than just using what you know, but in the end you’ll save lots of time - and making your analysis more robust in the process. Publication A bit of a no-brainer, because this is what most researchers are after anyway. There is little point doing lots of amazing research if you’re not communicating it (OK, I’m a bit guilty of that, with data from 2015 still waiting to be written up…). Some projects just take years, but the main thing is to always aim to have your results published. And this is where the dialogue with the journals comes in play: it shouldn’t just be about publishing statistically significant results. It should be about reproducible results, also when they are null-results. 1.5 Exercise: forensic science Exercise 1.1 Download the data for this course and look at the data/forensic-science folder. Try to answer the following questions: Look through the folder and try to answer the following questions about the project: What are the conclusions of this study? When was this study performed? What are the questions that this study is trying to answer? Which files are the data? Which files are the analysis? the output? How could we make this easier? Answer The data are of course a mess. This is not how you would like to tackle your analysis! There are no clear conclusions associated with the study (it’s not even clear which paper these data belong to). We have two images: graph.png, which seems to show that life expectancy (of what?) increases over time. The trend is not the same in draft_graph.docx, so they’re unlikely to be the same data set. 2. Not a clue. The only thing we can say is that it is after 2010, since the most recent data come from this year. 3. Probably the following: What is the trend in average life expectancy across countries, over time? What is the average life expectancy over time in Oceania? We have the following: Files: data.xls (probably how the data were collected, multiple worksheets); data1_full.csv (probably the data used to read into R); data1.xls (just the Gapminder worksheet); oceania.csv (the data for Oceania only) Analysis: final_analyses.R, final_analyses1.R and rev1_final_analyses.R all have very similar analyses, with different kind of filtering/subsetting and location of files (absolute/relative paths) Output: graph.png and draft_graph.docx show different things. graph.png has information on Canada (if that is the one generated by the script). The draft graph in the Word document is unclear, it seems like it was generated in Excel. Sack the researcher who did this. More seriously, teach the researcher some good scientific practices. Some of the things we could do differently is: provide a README file with information on the data: when was it collected, by whom, what are the units etc organise the data and analysis: have a raw folder for the raw data, processed folder for data files that have been changed/subsetted (using scripts!). Keep the scripts in a scripts folder and use an output folder for images use leading numbers for the analysis files, e.g. 01_process-data.R; 02_data-exploration.R, 03_graphs.R etc have commenting in the script, explaining what is being done; consider using some kind of markdown language (e.g. RMarkdown) to combine a narrative with code write down methods (e.g. statistical analyses) and conclusions in a separate file 1.6 Key points Reproducibility underpins the scientific method: being able to consistently obtain the same results for an experiment gives weight to the credibility of the outcome. We can influence reproducibility at every stage of the scientific method, by documenting our hypotheses and thought processes that led to them; by providing clear experimental design guidance and methods; by making our data and data analysis available an interpretable to others and finally, by letting other peer-review our research. 1.7 Authors and materials Some ideas in Chapter 3 are based on unpublished materials from Matt Castle (Bioinformatics Training Facility, University of Cambridge.The materials in Chapters 4 and 5 borrow from and are based on existing materials by Alexia Cardona. Parts of Chapter 6 and 7 are used in materials previously developed by Martin van Rongen. "],["installation-instructions.html", "Chapter 2 Installation instructions 2.1 Install RStudio 2.2 GitHub 2.3 Git software", " Chapter 2 Installation instructions Please ensure that you have done the following before the course (needed for version control exercises): 2.1 Install RStudio Make sure to have RStudio installed. You can download it here 2.2 GitHub You’ll need a GitHub account and a Personal Access Token to link GitHub with RStudio: Create a GitHub account on: https://github.com Set up a personal token to allow R Studio to link to GitHub (this is in place of using a password): https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token 2.3 Git software The software that keeps track of the different versions is git itself. You can follow the instructions here: https://support.rstudio.com/hc/en-us/articles/200532077-Version-Control-with-Git-and-SVN Later we will set up RStudio to access git and then it might be useful to know where git has been installed. This can be found out by either using the command git --exec-path from a command line prompt (Windows/Linux/Mac) or from the Terminal pane within R Studio. On a Mac/Linux computer you can also issue a which git command at the command line or R Studio Terminal. Results may differ between these commands as operating systems often use aliases that point to the real location of the program. MacOSX The installation instructions for Mac give you a few different options. The easiest option is probably to install using Xcode, but it’s a huge (GBs!) package that contains all kinds of other things you probably do not need. After that, you’re probably best off using homebrew - a package manager that allows you to install all kinds of interesting stuff via the command line. If you’re not comfortable with that, then see: the standalone installer provided by Tim Harper. "],["organisation.html", "Chapter 3 Organisation 3.1 Objectives 3.2 Exercise: tidy forensic science 3.3 Exercise: Me, me, me! 3.4 Key points", " Chapter 3 Organisation 3.1 Objectives Consider ways to organise and structure your data and analysis 3.2 Exercise: tidy forensic science Exercise 3.1 Use the data from the forensic science exercise to create a folder structure and file naming convention that tidies everything up. Answer A possible directory and file structure could look as follows: forensic-science |_ `forensic-science.Rproj` |_ data |__ raw |__ `2011-12-01_gapminder_data.xlsx` |__ processed |__ `subset-gapminder_worldregion_oceania.csv` |__ `subset-gapminder_yr1982.csv` |__ `subset-gapminder_country_canada.csv` |_ scripts |__ `fs-lifeyear_canada.R` |__ `fs-lifeyear_oceania.R` |__ `fs-lifeyear_yr1982.R` |__ `fs-figures.R` |_ output |__ documents |__ `manuscript-figure_captions.docx` |__ exploration |__ `fs-lifeyear_canada_1950to2000.png` |__ `fs-lifeyear_canada_2000to2002.png` |__ `fs-lifeyear_netherlands_1950to2010.png` |__ figures |__ `fs-lifeyear_canada_1950to2010.png` |__ `fs-lifeyear_oceania_1950to2010.png` |__ `fs-lifeyear_world_1982.png` |_ misc |__ `data-original_from_matthew.xlsx` 3.3 Exercise: Me, me, me! Exercise 3.2 Now that you’ve thought about structuring the mess I left you with in the forensic_science folder, it’s time to put your new, obsessively organised self to work on your own project(s). I’d like you to take one of your projects (preferably the one you’re still storing only on your Desktop…) and make a copy of it. Using the copy, I want you to reorganise your files into a coherent directory structure. Once you’ve done that, I need you to have a good look at the filenames. Are they clear? Are they providing information of what’s contained in the file? Do the files sort logically? 3.4 Key points Whatever system you use, make sure you have one! Store files in a logical directory structure Have a misc/stuff folder to store random stuff in Name your files so they give you information on what they contain Make sure files sort properly by tweaking your file names Be consistent, stick to the system you’ve chosen! "],["documentation.html", "Chapter 4 Documentation 4.1 Objectives 4.2 Libraries 4.3 RMarkdown 4.4 Markdown 4.5 Exercise: Getting started 4.6 R code chunks 4.7 Tables 4.8 Composing figures with patchwork 4.9 Exercise: Writing a short report 4.10 R Markdown limitations 4.11 Key points", " Chapter 4 Documentation 4.1 Objectives Be able to use basic markdown syntax Understand how to use R Markdown by integrating text formatting and R code Be able to create dynamic tables in R Know how to compose multipanel figures programmatically in R Part of these materials were originally developed by Alexia Cardona1. 4.2 Libraries Libraries Description tidyverse A collection of R packages designed for data science rmarkdown Converts markdown and R code into rendered documents kableExtra Generates dynamic tables patchwork Composes plots generated by ggplot() 4.3 RMarkdown R Markdown is integrated in RStudio and enables you to create documents, reports, presentations and dashboards. This in turn helps you to communicate your research better than using scripts alone. It does this because it supports extensive text formatting and easy code integration. That in turns enables you to walk a reader through an analysis much more easily than you would be able to do using comments in a script. An R Markdown file is made up of 3 basic components: header markdown R code chunks Here we will assume that the output of our report is an .html file. HTML files are files for web pages. This means that the report that we will generate can be easily deployed on the web. R Markdown can also be used to generate PDFs, Microsoft Word or Latex documents, among other things. 4.3.1 R Markdown header The markdown document starts with an optional header in YAML (YAML Ain’t Markup Language) format known as the YAML metadata. Oh yes, programmers have a very particular sense of humour… In the example below, the title, author and date are specified in the header. Other options can be specified in the header such as table of content which we will look at later on in the course. --- title: &quot;Reproducibility without fuss&quot; author: &quot;Martin van Rongen&quot; date: 20 Jul 1969 --- To create a new R Markdown file go to File -&gt; New File -&gt; R Markdown. To generate the output file (in this case an html document), press the knit button: Alternatively, use the corresponding keyboard shortcut (Mac Cmd + Shift + K, Windows Ctrl + Shift + K). 4.4 Markdown The text following the header in an Rmarkdown file is in Markdown syntax. This is the syntax that gets converted to HTML format once we click on the Knit button or the Build website button (yes, you can deploy whole websites using R Markdown). The philosophy behind Markdown is that it should be easy to write and easy to read. The full documentation of the Markdown syntax can be found at https://pandoc.org/MANUAL.html. However this might be a bit of information overload when you’re starting. Therefore below is a simplified version of the Markdown syntax. 4.4.1 Headings Below is the Markdown code you need to use to specify headings at different levels and the rendered output respectively below the code: # Heading 1 Heading 1 ## Heading 2 Heading 2 ### Heading 3 Heading 3 #### Heading 4 Heading 4 4.4.2 Inline text formatting To make text bold use **double asterisks** or __double underscores__. To make text italic use *asterisks* or _underscores_. To make text superscript use ^caret^. To make text subscript use ~tilde~. To mark text as inline code use `backticks`. To strikethrough text use ~~double tilde~~. 4.4.3 Line breaks To create a line break, put more than 2 spaces at the end of a sentence or place \\ in a new line followed by a new line . 4.4.4 Links 4.4.4.1 Linking text to Headers To link text to a header you would need to specify an identification tag next to a header as follows: # Markdown {#markdown-header} Then to link text to this header use [link to header](#markdown-header). This will be rendered as link to header. 4.4.4.2 Linking text to a webpage To create a link to a webpage use [text of link](https://www.gapminder.org). This is rendered as text of link. 4.4.4.3 Footnotes To indicate a footnote use[^2] and, for example, indicate another one as[^3] (I already used [^1]!) and then specify the wordings of the footnotes as: [^2]: This is a footnote. [^3]: Another footnote. You do not need to put footnotes at the end of the document for them to be rendered there. This example is rendered as follows: To indicate a footnote use2 and, for example, indicate another one as3 and then specify the wordings of the footnotes as: 4.4.5 Lists 4.4.5.1 Ordered lists To create an ordered list use the following syntax: 1. Item 1 2. Item 2 3. Item 3 This is rendered as: Item 1 Item 2 Item 3 Use 4 spaces to indent an item if you would like to have sub-lists: 1. Item 1 2. Item 2 3. Item 3 a. Item 3a i. Item 3ai ii. Item 3aii b. Item 3b c. Item 3c 4. Item 4 Item 1 Item 2 Item 3 Item 3a Item 3ai Item 3aii Item 3b Item 3c Item 4 4.4.5.2 Unordered lists In an unordered bullet list, each item begins with *, + or -. Example: * Item 1 * Item 2 * Item 3 * Item 3a * Item 3ai * Item 3aii * Item 3b * Item 3c * Item 4 Will be rendered as: Item 1 Item 2 Item 3 Item 3a Item 3ai Item 3aii Item 3b Item 3c Item 4 4.4.5.3 Tasks list Tasks list can be done using the following syntax: - [ ] an unchecked task list item - [x] checked item This will be rendered as: an unchecked task list item checked item 4.4.6 Inserting images To insert an image use the following syntax: ![Figure caption](path/to/image). Example: ![R Logo](img/Rlogo.png) Will be rendered as: R Logo You can adjust the size of the image by adding a width and height in pixels in between curly brackets, like this: ![R Logo](img/Rlogo.png){width=100px height=100px} will plot like R Logo 4.4.7 Blocks Blocks or quotes in the notebook can be created by using the &gt; sign as follows: &gt; &quot;Life can be great, when you try something new.&quot; &gt; &gt; _Kevin the koala_ This is rendered as: If you would like to add code blocks, use ``` before and after the code as follows: ``` print(&quot;Hello world&quot;) x &lt;- 1 + 2 print(x) ``` This will be rendered as: print(&quot;Hello world&quot;) x &lt;- 1 + 2 print(x)   4.4.8 Adding a table of contents To add a table of contents to your report add the following to the YAML header you need to specify the output (in this case a html_document) and set toc to true. If you want to make sure your table of contents stays visible even whilst scrolling, then you need to float it, using toc_float: true. output: html_document: toc: true toc_float: true By default all headings up to level 3 headings are displayed in the table of contents. You can adjust this by specifying toc_depth as following: output: html_document: toc: true toc_depth: 4 4.4.9 Adding references Adding references and citations in Markdown is not as easy as reference manager software such as Mendeley. To be able to create citations you will need to create a bibliography file with all the references in it. Here is an example of a bibliography file. The bibliography file has to be placed in the same folder as the one where the .Rmd file is. Next, add the following to the YAML header: bibliography: references.bib link-citations: yes Your YAML header should now look like: --- title: &quot;Reproducibility without fuss&quot; author: Martin van Rongen date: 19 Dec 1972 bibliography: references.bib link-citations: yes --- To cite a reference use the @ together with the ID of the reference. Example: Citation to my paper @cardona2014 and @cardona2019 Will be rendered as: Citation to my paper L. A. A. Cardona Alexia AND Pagani (2014) and A. Cardona et al. (2019) To add the bibliography at the end of the report add a References heading at the end of the report: # References See https://rmarkdown.rstudio.com/authoring_bibliographies_and_citations.html for more information. 4.5 Exercise: Getting started Exercise 4.1 To get you started, I’d like you to do the following: Create an R Project if you haven’t done so already Start a new R Markdown file and save it in the appropriate subfolder (e.g. notebooks) Think about one of your own projects and use that to come up with a title. Create three levels of headings, sub-dividing your project and try out some of the inline text formatting. Add a link to the https://www.gapminder.org website (or any other website). Use knit to render an html document and see if it looks like you expected. 4.6 R code chunks So far we have not used any R code and all the code we used so far is in Markdown. As the name suggests, Rmarkdown files contain markdown and R. Rmarkdown files have a .Rmd extension. Using R in a markdown document makes sense if we integrate our analysis in our report. Some operations that we might need to do are; loading our data set, performing some operations on the data set and displaying results, either in a table or in a plot. We will be doing all this in the following sections. If you would like to insert R code inside the notebook you will have to insert it inside an R code chunk to be able to execute it. To do this click on the Insert button at the top of the Source panel in RStudio: Or use the associated shortcut (Mac Cmd + Option + I, Windows Ctrl + Alt + I). This creates an R code chunk as follows: Alternatively, you can type the r code chunk (although I recommended using the keyboard shortcut). The R code should be placed in between the triple backticks. Note that on the right hand side of the R code chunk there is a green “play” button that will run the R code chunk if pressed. By default, when the Rmarkdown document is knitted, the R code will be executed and the R code chunk is displayed before the executed code. To run a chunk you can use the Run button or the shortcut (Mac Cmd + Shift + Enter, Windows Ctrl + Shift + Enter). 4.6.1 Chunk names It is possible to give names to chunks using ```{r chunk_name}. This has several advantages: You can navigate more easily through your R Notebook using the drop-down code navigator: Graphics produced by the chunks will have meaningful names based on the chunk name, which is a big improvement over Untitled1.png. One chunk name has special meaning: setup. In R Notebooks the chunk named setup will automatically run only once, before any other chunks are run. 4.6.2 Chunk options You can control the output of chunks with different options in the chunk header (e.g. {r, include = FALSE}). These chunk options include: eval = FALSE prevents code from being evaluated. No code is run and no output displayed. Useful to display example code or avoiding commenting out many lines. include = FALSE do not display the code and results in the page after it is knitted. The R code however still runs and therefore the variables or results in this code chunk can be used by the other chunks. echo = FALSE does not display the code, but it displays the results in the rendered file. message = FALSE or warning = FALSE prevents messages or warnings from being displayed in the rendered file. There are almost 60 options by knitr that you can use to customise your code blocks. A full list of options can be found here. 4.7 Tables Tables can be created manually or dynamically. 4.7.1 Manually creating tables Although probably only useful for small tables, you can manually create tables, using |and - as follows: | country_id | country | | ----------- | ----------- | | afg | Afghanistan | | ago | Angola | This is rendered as: country_id country afg Afghanistan ago Angola Table alignments can be done using the following syntax: | country_id (left) | country (centre) | world_region (right) | | :--- | :----: | ---: | | afg | Afghanistan | south_asia | | ago | Angola | sub_saharan_africa | This is rendered as: country_id (left) country (centre) world_region (right) afg Afghanistan south_asia ago Angola sub_saharan_africa 4.7.2 Dynamic tables using rmarkdown Clearly creating a large table this way is not very efficient or often even feasible when dealing with larger data sets. Furthermore, it goes against the principle of trying to make your research reproducible because the data are not generated through code. R Markdown has some basic functionality to create tables in HTML. The paged_table() function creates a table that supports paging rows and columns. When we use this on the built-in iris data set it looks like this: paged_table(iris) 4.7.3 Dynamic tables using kableExtra Apart from the basic functions available in rmarkdown, we can also use the kableExtra package, which uses the knitr::kable() function to generate tables. It allows you to build complex tables and adjust the table styles easily. More information can be found here. Let’s explore that a bit more by generating a table that displays the iris data set. The table is styled in twitter-fashion using kable_styling(), with striped rows that highlight when you hover over them. The table is embedded in a scroll box of a fixed dimension using scroll_box. Here I’m using the pipe symbol (%&gt;%) to pipe the output from one function to the next. iris %&gt;% kable(caption = &quot;Iris data set&quot;) %&gt;% kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;), full_width = FALSE) %&gt;% scroll_box(width = &quot;100%&quot;, height = &quot;400px&quot;) Somewhat frustratingly, pagination is not possible with kable. So if you have a long table, you are best off using the paged_table() function from the rmarkdown package. 4.8 Composing figures with patchwork Apart from using a markdown language to render your text output, it can also be very useful to compose figures programmatically. Of course it is possible to generate figures with multiple panels using image editing software, but that does not really fit in with the reproducibility ethos, does it? So how can we do this in R? There is a package that allows you to do just that for figures generated byggplot(): `patchwork’. If you need to install it, run the following code in your console: install.packages(&quot;patchwork&quot;) Then load the library: library(patchwork) Patchwork requires you to assign plots to an object and then you can use mathematical operators such as +, |, / to organise your figures. Let’s create three figures and go through the options. You can just copy/paste the code, because the figures themselves are not important. It’s the use of patchwork we’re focussing on. Plots: p1 &lt;- iris %&gt;% ggplot(aes(x = Petal.Width, y = Petal.Length)) + geom_point() p2 &lt;- iris %&gt;% ggplot(aes(x = Species, y = Sepal.Width)) + geom_boxplot() p3 &lt;- iris %&gt;% ggplot(aes(x = Sepal.Length, y = Sepal.Width, colour = Species)) + geom_jitter() 4.8.1 Adding plots together The simplest way to add plots together using patchwork is to use the + operator: p1 + p2 + p3 You can control how the plots are displayed. For example, we can put the third plot (p3 below the others): (p1 + p2) / p3 Or we can stretch out the first plot over two rows: p1 | (p2 / p3) We can then further customise the plot. We can add annotations using plot_annotation: add a title using title = add panel labels using tag_levels = (it takes different arguments, e.g. A for capital letters, a for lower case letters, I for Roman numerals etc.) (p1 | (p2 / p3)) + plot_annotation(title = &quot;Iris data set&quot;, tag_levels = &quot;A&quot;) There are more options available, which you can find on the patchwork website. 4.9 Exercise: Writing a short report Exercise 4.2 For this exercise I’d like you to create a new R Markdown file, and do the following: Create 3 heading levels, as previously done Add a table of contents Using the default mtcars data set, create a dynamic table create 2 plots in ggplot (e.g. scatter plot of disp vs hp; box plot of carb vs disp) create a two-panel figure in patchwork, with a title, caption and panel tag knit the document and admire your results 4.10 R Markdown limitations Some limitations that R Markdown has: Figure and table numbering is not supported. There is still a way around this, by using third-party packages e.g., captioner or bookdown (which is a great package to use when you want to group your analysis together in a book format!). If you are looking at specific customisations that are different from the default Markdown format, e.g., headings using different font specifications, then this gets tricky and markdown might not be the best approach. 4.11 Key points Markup languages allow you to perform document formatting in a programmatic way Useful for large documents Increases reproducibility of documentation These materials have been adapted from Reproducible research in R, which has been developed by Alexia Cardona.↩︎ This is a footnote.↩︎ Another footnote.↩︎ "],["version-control.html", "Chapter 5 Version control 5.1 Objectives 5.2 Introduction 5.3 Centralised version control systems 5.4 Distributed version control systems 5.5 Git workflow 5.6 Branches 5.7 Files under version control 5.8 Glossary 5.9 Key points", " Chapter 5 Version control 5.1 Objectives Understand different ways to deal with versions of data Understand the workflow for Git Know about when branches might be helpful 5.2 Introduction I would imagine that most people here will have found themselves in this situation before: I certainly have! And over the years I’ve tried different ways of organising revisions. For documents it works quite well to start your document title with a date, for example 2020-04-05_Project_analysis.docx so that a new version would have a more recent data, such as 2020-05-08_Project_analysis.docx. That way your revisions are organised in chronological order. If you are working with multiple people on the same document you can add initials to the end, e.g. 2020-04-05_Project_analysis_JD.docx, so you know who has reviewed/commented on the document. You can then merge documents within MS Word, if you’re using that. More recently, I’ve become a fan of Google Docs, which provides much of the functionality of MS Office, but allows you to work remotely on a document with other people. Changes are registered in its History and you can go back through time. All this works reasonably well for documents, but this is less suitable for code, where changes are made often and have clear consequences on the workings of the code further down. This gets us to the topic of version control systems, of which Git is one. Git allows you to keep track of changes to your code and share those changes with others. It works particularly well when used in conjunction with GitHub, a website that enables sharing your code with others. In general, there are two different types of version control systems: centralised and distributed. Both types of version control systems their changes in a database, called a repository. All work is done on a personal copy, called a working copy. We’ll briefly go through the differences between how these two systems function in this context. 5.3 Centralised version control systems The centralised version control system has just one centralised repository. Each user has its own working copy to which changes are made. These changes are then communicated with the central server that holds the (centralised) repository. You commit your changes to the server, other users update and can directly see your changes. Image by Michael Ernst. 5.4 Distributed version control systems The distributed version control system works a little different, where each user not only has their own working copy, but also their own repository. You commit your changes to your repository but other people cannot see those changes yet. For that to happen you need to push your changes to the central repository. You do not get other people’s changes, unless you specifically pull those changes into your own repository. Image by Michael Ernst. Here we will be using Git, which is a distributed version control system. Version control with Git works differently to all other version control systems in the way that it views the data. Whereas other version control systems store information as changes to a base version of a file (thus tracking how a file changes over time), Git stores data as a snapshot of the project over time. If a file has changed then Git stores the file again and if a file is unchanged then it links to the original, unchanged file. As such, Git can be thought of as a mini file system. 5.5 Git workflow Although Git can work entirely local, it is usually used in conjunction with a remote storage - in our case GitHub. You have a working directory on your computer that contains all the files that you are working on. There is also a local repository inside your working directory that contains an object database with all the versions of the files, changes, commits etc. associated with your files. Lastly, there usually is a remote repository that contains a copy of your local files and local repository. In our case, this remote repository is on GitHub. GitHub needs to know which files to track, which are added to the index. These files are staged for a commit, which creates a snapshot of your files in time. The commit is always accompanied by a message that explains what the changes are that are being committed. When you are happy with the commit you’ve made on your (local) computer, then you can push these changes to your remote repository on GitHub and it will be updated. The image was adapted from the RebelLabs Git Cheat Sheet. 5.6 Branches If you are working on something by yourself then you’re able to judge whether or not you want to push any changes to your remote repository. Things get a bit more complicated when you are working in a team, because multiple people could work on the same file and the changes you push could affect others. The way GitHub deals with this is through the use of branches. Simply put, a branch is a copy of your repository where you can safely make changes/experiment without worrying how these changes might affect others. There can be many different branches in your repository, but only one can be deployed: the master branch. So if you are making changes and push them to the master branch then they are immediately implemented. We will learn how to create branches later. Below is a schematic overview of the process you go through on GitHub. Image adapted from the GitHub guide. 5.7 Files under version control When you are using version control, you probably do not want to put every file and folder in your working directory under version control. After all, your working (or project) folder will likely contain binary files, such as text documents or presentations, and data that you want to keep separate. Data can take up lots of space and GitHub is not the place to store these files - it really is intended for code. Data associated with publications is usually shared via dedicated data repositories, such as Apollo - University of Cambridge Repository. But only putting part of the files under version control means that we need to tell git which files to keep track of, or not. It does so with a gitignore file, where we tell git which files to ignore. In a little while we’ll be creating our own repository on GitHub and there you have the option to add a .gitignore file from the start. However, I tend to forego on that, and let RStudio create one once I link a repository to RStudio (more on that later). You can add files and folders to a .gitignore file, and it might look something like this: .Rproj .RData data documents 5.8 Glossary The variety of phrases used in both types of version control systems can be a little overwhelming at times. Below is a non-exhaustive list of phrases you might come across. The glossary is an adapted version from here. branch a version of the repository that diverges from the main working project. Used to explore/test new features or make changes. clone a copy of a repository. commit stores the contents of the index (the staging area of Git) in a new commit. Needs to be provided with a commit message that explains what the changes are. fetch downloading and copying the files of a particular branch to your computer. fork creates a personal copy of somebody else’s repository. index working or staging area of Git. This is where files that have been changed/added/deleted are kept until you are ready to commit the files. master the primary branch of all repositories. merge takes the changes from one branch and adds them to another (usually the master branch). These commits are normally first requested via a pull request. origin is the conventional name for the primary version of a repository. Git uses origin as a system alias for pushing and fetching data to and from the primary branch. pull or pull request a term used in GitHub to let people know you’ve pushed changes into a branch of the repository. These changes can then be reviewed by the repository maintainer and can be merged. push updates a remote branch with the commits made to the current branch. You are pushing your changes onto the remote. remote a copy of the original branch. When you clone a branch, that new branch is a remote, or clone. repository In many ways, you can think of a Git repository as a directory that stores all the files, folders, and content needed for your project. What it actually is, is the object database of the project, storing everything from the files themselves, to the versions of those files, commits, deletions, et cetera. Repositories are not limited by user, and can be shared and copied. upstream While there is not necessarily a default “upstream” or “downstream” for Git projects, upstream can be considered where you push your Git changes — this is often the master branch of the project within the origin 5.9 Key points Version control can be centralised on a server, or distributed with a local copy of a repository The git model is distributed, with a local repository that can be linked to an online remote repository GitHub is an online platform for remote repositories, allowing easy sharing of and collaborations on repositories "],["github-1.html", "Chapter 6 GitHub 6.1 Objectives 6.2 Starting on GitHub 6.3 Exercise: New repository 6.4 Creating a new file (optional) 6.5 Creating a new branch (optional) 6.6 Pull requests (optional) 6.7 Exercise: Pull requests (optional) 6.8 Forking projects 6.9 Creating issues 6.10 Managing access 6.11 Key points", " Chapter 6 GitHub 6.1 Objectives Be able to create and delete repositories on GitHub Be able to create Issues Know how to fork an existing repository Manage access 6.2 Starting on GitHub 6.2.1 Creating a new repository Start a new repository by navigation to the top right corner on GitHub: This brings up a screen with the following options: Name of repository you want to create A short description of what the repository contains Make the repository Public or Private Check the Initialize this repository with a README to create a README file (recommended) Add a license (any license is better than none, but do look into what restrictions they impose) Create the repository 6.2.2 Deleting a repository It happens. Sometimes you might just want to delete a repository, for whatever reason. Nothing to be ashamed of. But useful to know how! You go to your repository &gt; Settings then scroll all the way down to the bottom. There you’ll find something called the Danger Zone. When you press the Delete this repository button, it’ll ask you to type in the name of the repository, to make absolutely sure that you know that you’re about to delete it. There’s no going back after that, so if you’re not sure you’ll need the code later on - leave it. 6.3 Exercise: New repository Exercise 6.1 For this exercise we’ll practice creating a repository. Create a new repository on your GitHub account Edit the README file and commit changes Remember the following: Use a meaningful name for your repository Initialise the repository with a README file Add an extension to the file name when creating a new file 6.4 Creating a new file (optional) We can add files directly from the GitHub interface. We’ll do this just to practice, but you’ll be unlikely to use this very often - I generally link a repository to an RStudio project and work that way. To create a new file, click on the Create new file button: You then have the possibility to create a new file, in this case we are calling it new_file.txt. Note the use of file extensions. A file extension is required! To add the file you need to add a commit message. A commit message should be a brief description of what you’ve done. You can add more information on how you have done things in the commit description. Here we are adding it directly to the master branch. We will learn how to create branches next. 6.5 Creating a new branch (optional) You usually create a new branch if you want to add or change something in the master branch, but you’re not entirely sure if it will work or affect others working on the same files. Creating a branch makes a copy of your repository that you can freely edit, without having to worry about these things. We will call this a feature branch. To create a feature branch, click on the Branch: master button on the main repository page. This will display a list of branches (if there are any). To add a new branch simply type in the name you want and press Enter. This new_branch will be the same as the master branch (because it is an exact copy). To generate some changes, we add a new file called file_in_new_branch.txt. Once committed, we are taken back to the main repository page (note that you are now in Branch: new_branch if you have created a branch called new_branch). Because you have made a copy of your repository and you have made some changes, GitHub now gives you the opportunity to compare your new_branch with the master branch. Comparing the branches enables you to generate a pull request, which enables you to let people know that you have made changes. This means that people can review the changes and implement them. We will do that next. 6.6 Pull requests (optional) To start a pull request, press the Compare &amp; pull request button. This takes you to a screen where you can add a message to whoever is maintaining the master branch, explaining what you have done in your new_branch and requesting to implement the changes. After you press the Create pull request button you have the opportunity to merge the two branches. At the bottom of the screen you can write a message to the person who generated the pull request. After you have merged the branches your feature branch becomes obsolete, so you can decide to delete it. Unless you want to make more changes, but it would be best to start a new branch for that again. You are taken back to the main repository page once the pull request is merged with the master branch. You can see the changes have been implemented, because you now have a file_in_new_branch.txt in your master branch. 6.7 Exercise: Pull requests (optional) Exercise 6.2 Pull requests are helpful if you’ve been contributing to a repository and you want the maintainer of the repository to consider adding the changes you’ve made to the main, live branch. Open a pull request Review the changes Make more changes and push them Review the new changes and commit them Merge the branch with the master branch 6.8 Forking projects So far we have used repositories that we created ourselves. But you might find that you want to add or make changes to a repository that somebody else owns. Or you like their project and want to adapt it to your needs. In that case you need to make a personal copy of that project. This is called forking. To fork a repository you need to navigate to the repository page on the maintainers GitHub account whilst logged into your own account. You then click on the fork button. The repository is then copied to your account: The forked repository will show up in your repository list. It will specify that it is a forked repository: Once you have forked a repository to your GitHub account you can make changes to it. Good practice is to create a new branch in your copy of the repository, so that you do not run the risk of confusing the master branch of your copy with the master branch of the original repository. In this case we’re adding a new branch called new_feature. After you have created a new branch on your forked copy you can start editing/adding as you like. You do this as you have done before, by staging and committing changes to your repository. When you want to suggest incorporating some of these changes into the original repository you will have to open a pull request. This works in the same way is described in the pull requests section, but instead of comparing two branches on the same repository, you are comparing the branch on your forked copy with the master branch of the original repository. Your pull request will show up in the original repository. Note that you can also see that the original repository has been forked: 6.9 Creating issues GitHub keeps track of bugs, improvements and tasks through Issues. The good thing about issues is that they can be shared and discussed with collaborators, in a similar way as to how the pull request system works. An issue is created from the Issues tab in the repository: A new issue requires a title and description. It’s good to try and be as concise and complete as possible so that the developer knows what it is that you want. You can label the issue - in this case it is an Enhancement, but there is a whole range of labels you can choose from. Labelling can be particularly helpful when there are many issues and it helps you organise and prioritise your work. Issues are always assigned a unique ID, which you can use to refer to them in comments: 6.10 Managing access When you have a public repository everyone can fork the repository and make changes to that (forked) copy. You can also invite people to collaborate on your project. In order to do that you need to go to the Settings &gt; Manage access page: Here you can invite collaborators and once they have accepted, then can open pull requests and make changes to the repository. To find repositories where you are a collaborator on you need to go to Settings &gt; Repositories. Unfortunately these repositories do not show up on your own Repositories tab. 6.11 Key points Repositories can be created and deleted on GitHub Branches are helpful when you’re working on a new feature/addition without affecting the live main branch Forking allows you to work on somebody else’s repository Issues are a useful tool to keep track of bugs, enhancements, ideas etc "],["github-and-rstudio.html", "Chapter 7 GitHub and RStudio 7.1 Objectives 7.2 Using GitHub from RStudio 7.3 Exercise: Version control in RStudio 7.4 Exercise: Branching and changes 7.5 Key points", " Chapter 7 GitHub and RStudio 7.1 Objectives Link an RStudio project with GitHub Create and edit files in RStudio Commit and push changes to GitHub 7.2 Using GitHub from RStudio Although you can do more or less all the version control aspects via the GitHub website, this is not very convenient when you are working on your R projects. Now you have an idea of how the GitHub workflow works, we can start to integrate these version control concepts with RStudio. 7.2.1 Linking Git and RStudio To use Git from within RStudio you need to make sure that Git can be found by RStudio. If you haven’t done so already, make sure to go to: Tools &gt; Global Options &gt; Git/SVN and check that ’Enable version control interface for RStudio projects` is enabled. Also, check that the path to Git is present and correct. 7.2.2 Starting a new project under Git control If you want version control of your R project, you need to make sure that the project is under control of Git. The easiest way to start this is by creating a new project that is linked to an existing GitHub repository. We can link a new project to the GitHub repository that we generated previously. To do this, we need to copy the URL for this repository. To do this, you have to go to the repository page and click on the Clone or download button. You can then copy the URL as shown below: Next, we need to create a new project. Go to File &gt; New Project &gt; Version Control &gt; Git. In Repository URL paste the link to your GitHub repository. Give the project a name (avoid spaces and try to use a meaningful name) and tell RStudio where to save it. It is useful to tick the Open in a new session box, so that your project opens in a new RStudio session. That way RStudio opens a session with a clean environment. Your project will open and your RStudio session should now have an extra tab in the top right corner (where your Environment is), named Git. This is where all the changes will show up as you work on your project. These options can also be found by using the button in the toolbar. When you have opened a file and look at the options under this button it also enables you to find differences from the last commit (if there are any) or view the commit history of that file. 7.2.3 Changes and your remote repository Let’s make some changes to our local repository, which is now under Git control. Here we are first creating a folder called notebooks and adding an R Markdown file named 01_import_and_clean_data.Rmd. Once you have created the file you’ll see the folder appearing in the Git tab. When you tick the Staged box, the Status changes to Added. This means that Git is tracking your file and will include it in the next commit. There are a few other icons that can appear in the Git pane, so here is an overview: , untracked file. Git has not seen this before and it needs to be added before changes are tracked. , added file. The file is now tracked by Git. , modified file. The file has been modified since the last commit. , deleted file. The file has been deleted since the last commit. When we edit the file a bit we can see how it changed by clicking on the Diff button in the Git toolbar. If we are happy with the changes then we can commit them. You can do this by pressing the Commit button in the Git tab and adding a commit message. All the files that are staged will be included in that particular commit. If there are files that you do not want to commit yet then you can untick them before pressing the Commit button. To ensure that the changes end up on your remote repository you need to push the changes. To do this, press the Push button in the top right corner. RStudio will give you a message that the changes are pushed: 7.3 Exercise: Version control in RStudio Exercise 7.1 To get us going, we need to have a repository to play with. You can either use the repository you’ve created previously, or create a new one: Create a new repository on GitHub Create a new R Project under version control Link the R Project with the remote repository 7.4 Exercise: Branching and changes Exercise 7.2 Now we’ve got a project under version control we can practice what we’ll do if we want to create a new feature to our existing repository, but do not want to send that to the main branch (yet). To do this, we use the following steps: Create a new branch (e.g. new_notebook or anything that describes the feature you’re adding) from within RStudio. To do this, use the following button in the Git pane: Create a notebooks folder and save a new R Markdown file in it. Ensure that changes to the new file are tracked. Make some changes to the file and commit them. Push the changes to the remote repository. 7.5 Key points You can link repositories to RStudio by cloning them Once cloned and under version control, you can commit and push changes to the remote repository "],["references.html", "Chapter 8 References", " Chapter 8 References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
